<!DOCTYPE html>
<html>
<head>
    <title>Разделяй и влавствуй. О продуктивности программирования</title>

    <!-- meta -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- css -->
    <link rel="stylesheet" href="../../../css/bootstrap.min.css">
    <link rel="stylesheet" href="../../../css/ionicons.min.css">
    <link rel="stylesheet" href="../../../css/pace.css">
    <link rel="stylesheet" href="../../../css/custom.css">

    <!-- js -->
    <script src="../../../js/jquery-2.1.3.min.js"></script>
    <script src="../../../js/bootstrap.min.js"></script>
    <script src="../../../js/pace.min.js"></script>
    <script src="../../../js/modernizr.custom.js"></script>
</head>

<body id="single">
<div class="container">
    <div class="container">
        <header id="site-header">
    <div class="row">
        <div class="col-md-4 col-sm-5 col-xs-8">
            <div class="logo">
                <h1><a href="../../index.html"><b>Konoplev's</b> Blog</a></h1>
            </div>
        </div><!-- col-md-4 -->
        <div class="col-md-8 col-sm-7 col-xs-4">
            <nav class="main-nav" role="navigation">
                <div class="navbar-header">
                    <button type="button" id="trigger-overlay" class="navbar-toggle">
                        <span class="ion-navicon"></span>
                    </button>
                </div>

                <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                    <ul class="nav navbar-nav navbar-right">
                        <li class="cl-effect-11"><a href="../../index.html" data-hover="About">About</a></li>
                        <li class="cl-effect-11"><a href="../../thoughts/index/1.html" data-hover="Мысли">Мысли</a></li>
                        <li class="cl-effect-11"><a href="../../programming/index/1.html" data-hover="Программирование">Программирование</a></li>
                    </ul>
                </div><!-- /.navbar-collapse -->
            </nav>
            <div id="header-search-box">
                <a id="search-menu" href="#"><span id="language-icon" class="ion-android-globe"></span></a>
                <div id="language-form" class="language-form">
                    <div id="searchform">
                                                                        
                        <div class="text-center"><a href="../../../en/programming/post/divide_and_conquer._about_developers_productivity.html" data-hover="In english">In english</a><div>
                            <button type="submit"><span class="ion-android-globe"></span></button>
                        </div>
                        </div>
                    </div>
                </div><!-- col-md-8 -->
            </div>
</header>    </div>
</div>

<div class="content-body">
    <div class="container">
        <div class="row">
            <main class="col-md-12">
                <article class="post post-1">
                    <header class="entry-header">
                        <h1 class="entry-title">Разделяй и влавствуй. О продуктивности программирования</h1>
                        <div class="entry-meta">
                            <span class="post-date"><a href="#"><time class="entry-date" datetime="2019-04-30T22:00:00Z">May 1, 2019</time></a></span>

                            <span class="post-category">
                                                                    <a href="../tag/productivity/1.html"> #productivity</a>
                                                            </span>

                        </div>
                        <figure class="img-responsive-center">
                            <img class="img-responsive" src="./razdelyai_i_vlavstvui._o_produktivnosti_programmirovaniya.png" alt="Developer Image"/>
                        </figure>
                    </header>
                    <div class="entry-content clearfix">
                        <div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Очень сложно измерить продуктивность разработчиков. Строки кода, количество функций или количество багов - плохие метрики. Но все мы интуитивно знаем, что такое производительность. Для меня быть продуктивным означает делать все как можно быстрее и сводить к минимуму потерянное время, насколько это возможно. Этот пост о способах повышения производительности.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_Скорость_и_направление">Скорость и направление</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Давайте начнем с простых вопросов. Почему мы хотим быть продуктивными?</p>
</div>
<div class="paragraph">
<p>Жизнь слишком коротка, а время всегда ограничено, поэтому мы хотим делать больше за меньшее время. И, с моей точки зрения, продуктивность не означает спешку. Быть продуктивным - значит выбирать лучшие инструменты, правильные подходы, уметь быстро определять верное направление и разумно инвестировать время. Направление важнее скорости. Многие движутся в никуда очень быстро.</p>
</div>
<div class="paragraph">
<p>Этот пост о личной продуктивности. И этот пост в основном о продуктивности разработчиков, а это означает, что все примеры взяты из моего опыта, и некоторые из них будут проиллюстрированы кодом. Но эти же принципы применимы и в других областях.</p>
</div>
<div class="sect2">
<h3 id="_Автоматизируй_это">Автоматизируй это</h3>
<div class="paragraph">
<p>Несмотря на то, что этот пост предназначен для разработчиков, не лишним будет упомянуть, что простые действия должны быть автоматизированы. Хорошие разработчики стараются максимально избегать скучной ручной работы. Если вы выполняете одну и ту же последовательность шагов несколько раз, вы, вероятно, не думаете об этом и делаете это автоматически. Поручите это компьютеру, чтобы автоматическая работа выполнялась действительно автоматически. Не тратьте свое время на простые вещи. Машина не делает глупых ошибок, она более предсказуема и экономит время, позволяя вам думать о сложных вещах.</p>
</div>
<div class="paragraph">
<p>К сожалению, некоторые действия нельзя делегировать, но они могут быть автоматизированы. Например, нам все еще нужно писать код вручную (его нельзя загрузить в компьютер напрямую из головы). Слепая печать и горячие клавиши значительно повышают производительность. Вы не тратите время на перемещение взгляда между клавиатурой и монитором, вы не тратите время на перемещение курсора мыши, чтобы открыть меню и выбрать какой-либо элемент. Вы чувствуете, что ваши мысли транслируются в код без каких-либо усилий. Это потому, что работает <a href="https://en.wikipedia.org/wiki/Muscle_memory">моторная память</a>. Вы сосредоточены на том, что вы делаете, а не на том, как вы это делаете.</p>
</div>
</div>
<div class="sect2">
<h3 id="_Продуктивное_мышление">Продуктивное мышление</h3>
<div class="paragraph">
<p>После автоматизации простых шагов большая часть времени уходит на размышления. Вы думаете о чем-то, когда у вас нет решения, и вам нужно его найти. Или есть несколько решений, и вам нужно выбрать лучшее. А иногда вообще не понятно, как подойти к задаче. Или вы реализуете какое-то решение, но чувствуете, что есть лучший способ, который требует некоторых исследований. Вы могли бы потратить много времени на размышления и не добиться прогресса. Это заставляет вас нервничать, потому что время всегда ограничено, и вы начинаете что-то реализовывать просто для того, чтобы что-то сделать, но затем вы понимаете, что пошли в неправильном направлении, и было бы лучше потратить это время на размышления. Так как сделать ваше мышление продуктивным?</p>
</div>
</div>
<div class="sect2">
<h3 id="_dīvide_et_imperā">Dīvide et imperā</h3>
<div class="paragraph">
<p>Существует алгоритм, который называется <a href="https://ru.wikipedia.org/wiki/Разделяй_и_властвуй_(информатика)">Разделяй и влавствуй</a>. Идея состоит в том, чтобы рекурсивно разделять большую задачу на маленькие подзадачи, пока подзадачи не станут достаточно простыми для решения. После решения подзадач вы объединяете результаты, чтобы решить начальную задачу. Есть много подходов и методологий, основанных на этой идее. <a href="https://en.wikipedia.org/wiki/Lean_manufacturing">Lean</a>, <a href="https://en.wikipedia.org/wiki/Agile_software_development">agile</a>, <a href="https://en.wikipedia.org/wiki/TRIZ">triz</a>, и много много других. Если у вас есть что-то большое и неуправляемое, разбейте его на маленькие управляемые части.</p>
</div>
<div class="paragraph">
<p>Почему этот способ так распространен? Наш разум очень ограничен. Нам сложно все держать в голове. Вы не можете быть сосредоточены на нескольких уровнях задачи одновременно. Разбиение всего на мелкие части позволяет вам управлять своим вниманием.</p>
</div>
<div class="sect3">
<h4 id="_Запишите_это">Запишите это</h4>
<div class="paragraph">
<p>Размышление о проблеме - очень неуправляемая вещь. У вас нет решения, и что-то неясно, поэтому вы не можете оценить, сколько времени вам нужно, чтобы найти решение, вы даже не можете сказать, найдете ли вы решение или нет. Давайте начнем разбивать это на маленькие части. Первым шагом в решении любой проблемы является понимание проблемы. Прежде чем пытаться найти решение, я обычно пытаюсь понять, почему это проблема и почему я собираюсь ее решить. Эти простые вопросы сэкономили мне много времени. Очень часто я приходил к тому, что проблема, которую я собираюсь решить, является побочным эффектом другой проблемы или не является проблемой вообще. <a href="http://knoplev.me" class="bare">http://knoplev.me</a> [Здесь] я описал, почему важно все записать. В двух словах, это позволяет вам выгрузить все из головы на лист бумаги и освободить место для ваших вопросов и идей.</p>
</div>
</div>
<div class="sect3">
<h4 id="_План_и_прототип">План и прототип</h4>
<div class="paragraph">
<p>Как только я вижу проблему, я обычно пытаюсь определить, что я уже знаю, а что неясно. Все вопросы и все неясные моменты также написаны. Так я разбиваю проблему на более мелкие части. Я знаю, что делать с некоторыми частями, другие части до сих пор не ясны. На этом этапе моя цель - определить наиболее рискованные части и попытаться разобраться с ними. Есть разные причины, почему что-то рискованно:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Я никогда не видел такой проблемы раньше. Мне нужно найти способы ее решить. Это может включать изучение некоторых теоретических вещей, технологий, языков программирования и т.д.</p>
</li>
<li>
<p>Я знаю теорию, но практически никогда не делал этого.</p>
</li>
<li>
<p>Я знаю, как решить проблему, но я не уверен, что именно этого ожидают пользователи. Или я знаю, как что-то реализовать, но я не уверен, что это будет соответствовать требованиям производительности, ограничениям по памяти или другим требованиям и ограничениям.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Я расскажу о первом пункте позже в разделе «Изучение нового», потому что это большая тема. Иногда проблемы третьего типа могут быть решены путем обсуждения решений с другими участниками разработки продукта. Если кто-то лучше понимает, как должно выглядеть решение, то быстрее обсудить, чем реализовать. Но обычно проблемы 2 и 3 должны быть реализованы, чтобы убедиться, что вы на правильном пути. Иногда самая рискованная часть - это последний шаг в разработке продукта. Например, на последнем шаге я собираюсь использовать некоторую базу данных, чтобы сохранить результаты обработки, и я не уверен, что эта база данных соответствует нашим требованиям к производительности. Изменение базы данных на последнем шаге может привести к архитектурным изменениям, и это очень дорого. Чтобы избежать этой проблемы, следует проверить наиболее опасные части системы, пока не стало слишком поздно. И лучшая проверка - реализовать прототип. Поэтому я бы реализовал слой сохранения данных до того, как получу реальные данные. Я могу скормить в него сгенерированные не настоящие данные, которые имеют тот же размер и схему, что и будущие реальные данные, чтобы убедиться, что реализация соответствует нашим требованиям к производительности. Итак, я убил двух зайцев одним выстрелом. Я проверил свою идею и реализовал проверку производительности для части системы. Так я предпочитаю реализовывать что угодно. Этот способ работает для реализации новой сложной системы, новой функции или просто небольшого исправления ошибки. Разделите задачу на небольшие управляемые части, расставьте приоритеты, реализуйте шаг за шагом.</p>
</div>
<div class="paragraph">
<p>Иногда задача не является рискованной, но может заблокировать кого-то другого. Это так же должно быть прянято во внимание во время расстановки приоритетов.</p>
</div>
</div>
<div class="sect3">
<h4 id="_Взгляд_с_высоты_птичьего_полета">Взгляд с высоты птичьего полета</h4>
<div class="paragraph">
<p>Есть хороший способ справиться со сложностью. Он называется абстракция. Например, вам не нужно знать, как работает двигатель внутреннего сгорания для управления автомобилем. Автомобиль - это руль, педали, коробка передач, зеркала и четыре колеса, которые доставляют вас из пункта А в пункт В. Это абстракция автомобиля, которой пользуется большинство людей. Абстракция позволяет нам не заботиться о ненужных деталях. Разработчики тоже создают абстракции. Вам не нужно знать, как работает SDD диск на низком уровне, чтобы записать в файл. И на большинстве языков программирования один и тот же код записывает файл на HDD и SDD. Найти хорошую абстракцию действительно сложно. Чтобы найти хорошую абстракцию, нужно уметь обобщать.
Как только все неясные детали уточнены, я пытаюсь увидеть картину целиком с высоты птичьего полета. На данном этапе я пытаюсь убедиться, что неясных частей не осталось. Мне нужно проверить, что я перевел все бизнес-требования на технический язык. Всегда есть некоторый язык, описывающий бизнес-требования (который называется языком описания в терминах DDD), а технический язык - это абстракции, которые вы создали для отображения бизнес-терминов на языке программирования.
Проверьте требования один за другим и проверьте уровни абстракций один за другим. Как только вы увидите, что все требования транслированы, самое время задуматься о тестировании и внедрении.</p>
</div>
<div class="paragraph">
<p>Я хотел бы добавить примечание для перфекционистов. Вы всегда думаете, что, может быть, вы что-то упустили, вы пытаетесь избежать всех проблем. Это невозможно. Как только вы почувствуете, что ваши абстракции достаточно хороши и неясных моментов не осталось, переключитесь на тестирование, потому что это тоже часть всей картины. Возможно, на каком-то этапе вы поймете, что что-то упустили. Это нормально. Вы всегда можете провести &lt;&lt; Рефакторинг &gt;&gt;.</p>
</div>
<div class="paragraph">
<p>Зачем нужна вся картина, прежде чем вы начнете кодировать? Когда вы пишете код и сталкиваетесь с какой-то проблемой, вам нужно остановиться и подумать об этом. Это не продуктивно. Вы переключаетесь с одного вида деятельности на другой, что всегда означает, что вы теряете контекст. Вы думали о каком-то низком уровне, о некоторых деталях при кодировании, и вы поняли, что вам нужно перейти на более высокий уровень, потому что существует конфликт между деталями и абстракциями. Даже если вы нашли решение, требуется время, чтобы обновить контекст и продолжить кодирование. В худшем случае вам нужно переопределить то, что вы реализовывали раньше. В этом случае вы теряете еще больше времени. Наличие целой картинки перед кодированием позволяет избежать этих проблем. Это цель полной картины.</p>
</div>
<div class="paragraph">
<p>Многие пытаются пропустить этот шаг как можно быстрее и начинают кодировать. Но цена ошибки во время проектирования намного ниже, чем во время имплементации. Если вы обнаружите ошибку в своем плане, вы можете быстро изменить план, потому что он есть только у вас в голове и на листе бумаги. Если вы обнаружите архитектурную проблему на последнем этапе проекта, это очень дорого исправлять, потому что вам придется много переделывать. Проверяйте идеи в то время, когда исправить ошибки легко.</p>
</div>
</div>
<div class="sect3">
<h4 id="_Кодирование_Сверху_вниз">Кодирование. Сверху вниз</h4>
<div class="paragraph">
<p>Начните с создания основных объектов. Никакой реализации не требуется. Просто классы, сигнатуры методов и комментарии внутри методов. Так вы очень быстро переносите всю свою картинку из головы в код. Этот способ позволяет быстро проверить свои абстракции. Сосредоточьтесь на абстракциях на этом шаге. Как только у вас появятся шаблон для будущей реализации, вы можете проверить все еще раз и убедиться, что ваши абстракции работают.</p>
</div>
<div class="paragraph">
<p>Это применимо на всех уровнях. Представьте, что вам нужно объединить некоторые данные, которые требуются клиенту в некотором DTO, и отправить их. DTO имеет 6 полей, и есть несколько сервисов, предоставляющих фрагменты данных.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Data
@Builder
public class UserDto {
    private final UserId userId;
    private final String firstName;
    private final String lastName;
    private final UserPic userPic;
    private final List&lt;Orders&gt; orders;
    private final List&lt;Item&gt; wishList;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Вы можете извлекать значения полей из сервисов один за другим и устанавливать их в DTO. Но в этом случае очень легко что-то забыть.</p>
</div>
<div class="paragraph">
<p>
<div class="embed-responsive embed-responsive-16by9">
<iframe class="embed-responsive-item" src="https://www.youtube.com/embed/iaQCLDHomFQ" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen>
</iframe>
</div>
</p>
</div>
<div class="paragraph">
<p>Например, на видео мы забыли &#8230;&#8203; заметили? Да, мы забыли задать <code>userId</code>.</p>
</div>
<div class="paragraph">
<p>Другой способ - скопировать все поля для заполнения в метод. У вас есть плейсхолдеры для всех полей, поэтому вы никогда не забудете задать какое-либо поле.</p>
</div>
<div class="paragraph">
<p>
<div class="embed-responsive embed-responsive-16by9">
<iframe class="embed-responsive-item" src="https://www.youtube.com/embed/9q4xQm-8JwI" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen>
</iframe>
</div>
</p>
</div>
<div class="paragraph">
<p>Таким образом вы переходите от интерфейсов и высокого уровня к деталям низкого уровня и реализации. Этот способ позволяет вам быстро проверить свои абстракции. А также, поскольку вы импелементируете слой за слоем, вам не нужно переключать фокус с низкоуровневых абстракций на высокоуровневые абстракции, вы всегда работаете на каком-то определенном уровне, поэтому вам легче быть сфокусированным.</p>
</div>
</div>
<div class="sect3">
<h4 id="_Тестируйте_пока_не_слишком_поздно">Тестируйте, пока не слишком поздно</h4>
<div class="paragraph">
<p>Все совершают ошибки. В каждой программе есть баги. Наша цель - минимизировать их и поймать самые важные на ранних стадиях. Некоторые разработчики считают, что написание тестов - пустая трата времени. Или, по крайней мере, тесты имеют более низкий приоритет, чем код. Я не могу быть продуктивным без тестов. Модульные, интеграционные, end-to-end, перфоманс тесты - единственный способ убедиться, что мой код работает. Если мой код не работает, если у него есть критические проблемы, то его реализация была пустой тратой времени. Я не большой поклонник TDD, но я уверен, что тесты не следует откладывать. Это не должно быть последним шагом разработки. Если у вас большой объем кода и у него много проблем, то решение этих проблем может занять больше времени, чем реализация кода. Тесты позволяют мне легко изменять мой код, потому что я знаю, что ничего не сломал, мои тесты проходят. Исправление кода без тестов непредсказуемо. Вы исправляете что-то, но ломаете какую-то другую часть. Вы можете получить комбинаторный взрыв ошибок. И иногда действительно быстрее переписать все с нуля, чем исправить все ошибки в существующем коде.</p>
</div>
<div class="paragraph">
<p>И еще один момент. Если у вас нет тестов и вам нужно воспроизвести какую-то проблему, то единственный способ - запустить систему вручную и выполнить вручную все шаги, которые приводят к проблеме. Если вы дебажите проблему, вам, вероятно, потребуется воспроизвести ее несколько раз. Это скучно и требует много времени. Тесты позволяют автоматизировать воспроизведение ошибок (так &lt;&lt; автоматизируй это &gt;&gt;).</p>
</div>
<div class="paragraph">
<p>Суть в том, что вам нужен способ проверить, работает ли ваш код. Если вы не знаете, как его проверить, писать код пока рано. Это на самом деле идея TDD, с моей точки зрения. И дело не только в тестах. Как бы вы проверили, что ваша система работает? Сколько ресурсов он использует? Из-за чего она может упасть? Как можно это предотвратить?</p>
</div>
</div>
<div class="sect3">
<h4 id="_Все_хорошо">Все хорошо?</h4>
<div class="paragraph">
<p>Как только у меня есть полная картина, пришло время приступить к имплементации системы. Все уже разбито на мелкие части и расставлено по приоритетам, поэтому я знаю шаги.
После каждого шага хорошо бы проверять, что все в порядке. Посмотрите на всю картину еще раз, проверьте направление своего движения. После каждого шага я узнаю что-то новое и иногда осознаю, что разница между моим планом и практикой не так велика в плане, как в практике. Вот почему очень важно сделать ретроспективу и исправить курс.</p>
</div>
</div>
<div class="sect3">
<h4 id="_Рефакторинг">Рефакторинг</h4>
<div class="paragraph">
<p>Мы уже говорили об абстракциях. Иногда требования и меняются, и абстракции протекают. Плохие абстракции делают код не читаемым и неуправляемым. Я, как правило, не трачу время, чтобы сделать свои абстракции идеальными. Я знаю, что, вероятно, я буду их менять во время разработки. Это не значит, что у меня нет видения будущих компонентов системы. Как я описал в <a href="#Плане и прототипе">[Плане и прототипе]</a>, у меня есть представление о системе, прежде чем я начну ее внедрять. Суть в том, что я не пытаюсь обобщать слишком сильно. Например, я мог бы потратить много времени, пытаясь создать очень продуманный API некоторого микросервиса. Я мог бы попытаться избежать любых возможных проблем, попытаться предсказать, как API будет использоваться различными потребителями. Но после того, как API будет готов, я могу увидеть, что некоторые методы не используются, а некоторым потребителям требуется другое представление данных. Требования меняются очень быстро. Лучше попытаться создать что-то маленькое, полезное, управляемое и гибкое, чем пытаться избежать каких-либо проблем и тратить много времени на создание швейцарского армейского ножа. В большинстве случаев вам все равно придется его реорганизовывать.</p>
</div>
<div class="paragraph">
<p>Поэтому в большинстве случаев лучше создавать систему сверху вниз. Сначала имплементируйте интерфейсы высокого уровня и идите глубже. Начните с точки входа вашей системы (или компонента). Реализуйте методы для получения ввода и фиктивные методы для его обработки. Идите глубже, создавая интерфейсы и плейсхолдеры везде. Как только система выглядит хорошо, начните добавлять код в пустые методы и тестируйте их один за другим. На каком-то уровне вы можете осознать, что вам нужно получить что-то большее из высоких уровней, вернитесь назад и проведите рефакторинг высоких уровней. Вот как вы можете очень быстро создать каркас системы и протестировать свои абстракции. Этот способ позволяет избежать напрасной траты времени на реализацию деталей, которые не соответствуют вашим абстракциям. Итак, вкратце, начните с интерфейсов и отложите реализацию. Так вы можете проверить свои абстракции.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_Изучение_нового">Изучение нового</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Червонная Королева сказала Алисе: «Нужно бежать со всех ног, чтобы только оставаться на месте, а чтобы куда-то попасть, надо бежать как минимум вдвое быстрее!». Я думаю, что это было о разработке программного обеспечения и обучении. Как я уже говорил, абстракции позволяют нам разрабатывать новые вещи и не заботиться о деталях. Огромное количество абстракций создается каждый день, и мы должны бежать как можно быстрее, чтобы освоить их. Какого-то универсального решения не существует, поэтому, чем больше абстракций вы знаете, тем лучшее решение вы выберете для своих задач. Но рано или поздно мы сталкиваемся с проблемой, возникшей на низком уровне, и детали становятся важными. Мы должны бежать вдвое быстрее, чтобы понять, как работает абстракция, чтобы решить проблему.</p>
</div>
<div class="sect2">
<h3 id="_Новое_всегда_не_предсказуемо">Новое всегда не предсказуемо</h3>
<div class="paragraph">
<p>Скажем, вы младший разработчик, и вы только что узнали новую классную абстракцию. Абстракция называется map (или иногда она называется dictionary). Она позволяет найти значение по ключу, а сложность по времени является постоянной величиной O (1) (поэтому она не зависит от размера коллекции). Как это круто!</p>
</div>
<div class="paragraph">
<p>Вы начали ее использовать. Вы создали свой собственный класс Key.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class Key {
    private int value;

    public Key(int value) {
        this.value = value;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Key)) return false;
        Key key = (Key) o;
        if (value != key.value) return false;
        return true;
    }

    @Override
    public int hashCode() {
        return value;
    }

    public void setValue(int value) {
        this.value = value;
    }

    public int getValue() {
      return this.value;
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Вы написали некоторый Java код, используя map. Все было хорошо, но через некоторое время вы столкнулись со странной проблемой. Вы пытаетесь получить значение по ключу, но его больше нет.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Map&lt;Key, String&gt; map = new HashMap&lt;&gt;();
Key key = new Key(42);
map.put(key, "Goodbye, mad world");

//a lot of code here
//but we omit it

//get value
log.debug("value is '{}'", map.get(key));

//has the map size been changed?
log.debug("map size is '{}'", map.size());

//do we still have the key in the map?
Key firstKey = map.keySet().iterator().next();
log.debug("check hash codes. equals? '{}'", firstKey.hashCode() == key.hashCode());
log.debug("is it the same key? '{}'", firstKey.equals(key));

//does map contain the key?
log.debug("map contains key? '{}'", map.containsKey(key));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Вы добавили несколько логов, и результат действительно странный.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>value is 'null'
map size is '1'
check hash codes. equals? 'true'
is it the same key? 'true'
map contains key? 'false'</pre>
</div>
</div>
<div class="paragraph">
<p>Что случилось? Ключ все еще в мэпе. Но вы не можете получить его.</p>
</div>
</div>
<div class="sect2">
<h3 id="_not_ok_google">Not OK, Google</h3>
<div class="paragraph">
<p>Если это не ваш домашний проект, время, вероятно, очень ограничено. Вы должны решить проблему и двигаться дальше. Быстрый и простой способ - просто погуглить. Возможно, кто-то сталкивался с той же проблемой, починил ее и описал решение.
Почему этот путь не подходит?</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Нет гарантии, что вы найдете ответ.</p>
</li>
<li>
<p>Вы должны тратить время на чтение о различных проблемах, пытаясь скопировать некоторые решения в ваш код и &#8230;&#8203; см. Пункт 1.</p>
</li>
<li>
<p>Даже если вам повезет, и ответ найден и скопирован в ваш код, очень маловероятно, что вы чему-то научились. Вы просто скопировали чужое решение.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Ну хорош, у меня действительно нет времени углубляться, пытаясь понять причину проблемы! Мне просто нужно решение. Все ждут фикса, мой начальник не доволен.</p>
</div>
<div class="paragraph">
<p>Иногда это так. И я видел, как разработчики часами гуглили и пробовали разные решения. Я даже знаю разработчиков, которые думают, что им не нужно ничего читать о новом языке. Они просто пытаются использовать новый язык для реализации какого-либо проекта и гуглят, чтобы исправить любые возникающие проблемы.</p>
</div>
<div class="paragraph">
<p>Как я описал в «Dīvide et imperā», если вы понимаете проблему, но не знаете, как ее решить, попробуйте разбить проблему на небольшие управляемые части.</p>
</div>
<div class="paragraph">
<p>Я не знаю, как map работает под капотом. Все, что я знаю, это то, что я вставил в него пару ключ-значение, и я не могу получить значение по ключу. Давайте начнем разбивать проблему.</p>
</div>
<div class="paragraph">
<p>Каковы возможные причины?</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Map не работает. Он был реализован неправильно, и получить ключ по ключу невозможно.</p>
</li>
<li>
<p>В большинстве случаев map работает, но я нашел какой-то редкий случай, в котором - нет.</p>
</li>
<li>
<p>Map абсолютно в порядке, но я использовал его неправильно.</p>
</li>
<li>
<p>Я использую map правильно, но другая часть кода (например, другой поток, работающий параллельно) портит мой map.</p>
</li>
<li>
<p>Мой код в порядке, но что-то не так с моей средой окружения, и это как-то влияет на map.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Чем больше наш младший разработчик знает, тем более подробными будут пункты.</p>
</div>
<div class="paragraph">
<p>Это не просто «я понятия не имею, что происходит». Наш младший разработчик должен проверить некоторые теории. Теории могут быть расставлены по приоритетам и проверены одна за другой. Гипотеза 1 выглядит как хорошее начало. Потому что это ее легко проверить. Наш младший разработчик добавляет еще одну пару ключ-значение в map, и я уверен, что на этот раз новое значение доступно по новому ключу. Итак, map работает. У нас осталось меньше пунктов для проверки.</p>
</div>
<div class="sect3">
<h4 id="_Сделай_так_чтобы_это_работало">Сделай так, чтобы это работало</h4>
<div class="paragraph">
<p>Хорошо. Теперь у нас есть рабочий map. Мы знаем хотя бы один случай при котором все хорошо. И даже если у нас нет документации и мы находимся в самолете без доступа к Google, мы уже можем добавлять точки останова в исходники map, запускать отладчик и сравнивать работающий и не работающий пути.</p>
</div>
<div class="paragraph">
<p>И это еще одна причина разбивать большие задачи на маленькие. Вы начинаете с небольшой части большой вещи. После того, как вы закончили ее и добавили регрессионные тесты, вы можете постепенно добавлять более сложные вещи. Если что-то не работает, вы всегда можете вернуться к истории изменений в вашей системе контроля версий и проверить, что было изменено. Проблема в изменениях. (И именно поэтому полезно делать коммиты после выполнения любой небольшой части работы).</p>
</div>
<div class="paragraph">
<p>Такой подход позволяет быстро освоить новые технологии. Даже если у вас нет времени читать документацию или книги, но вы нашли какое-то учебное пособие или просто рабочий пример, это хорошая отправная точка. Вы запускаете его, смотрите, как он работает, и меняете его шаг за шагом, чтобы подогнать к вашим требованиям.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_Разделение_обучения_и_программирования">Разделение обучения и программирования</h3>
<div class="paragraph">
<p>Но в идеале лучше выделить немного времени для изучения новых вещей. Если вы только начинаете изучать какие-то новые технологии, не стоит добавлять эти технологии в ваш проект и пытаться заставить их работать вместе. Как только у вас возникнут какие-то проблемы, найти основную причину будет сложнее, потому что это часть проекта. Иногда трудно определить, возникла ли проблема из-за новой технологии или старых ошибок.</p>
</div>
<div class="paragraph">
<p>Вот почему у нас есть гипотезы 4 и 5. Наш младший разработчик начал использовать map без глубокого понимания внутренних деталей, и теперь map - часть большого проекта. Он не изолирован. Поэтому трудно исключить влияние существующего кода из возможных причин проблемы.</p>
</div>
<div class="paragraph">
<p>Еще одна причина потратить некоторое время на изучение новой технологии, прежде чем использовать ее в реальном проекте, заключается в том, что вероятность возникновения проблем очень велика. Вы не уверены, что используете незнакомую технологию правильно, поэтому легко ошибиться. Любая ошибка заставляет вас гуглить или читать книгу / учебник / исходный код, чтобы найти решение. Так что это та же проблема, что я обсуждал в разделе &lt;&lt; Взгляд с высоты птичьего полета &gt;&gt;. Вам нужно переключиться с кодирования на поиск в Google и наоборот. Вы теряете контекст каждый раз, и вам нужно потратить некоторое время, чтобы вспомнить, что вы делали. Это не эффективно.</p>
</div>
</div>
<div class="sect2">
<h3 id="_Не_боритесь_с_технологиями">Не боритесь с технологиями</h3>
<div class="paragraph">
<p>Еще одна причина изучить новую технологию, прежде чем добавлять ее в свой проект&#8230;&#8203; Она может не подходить к вашему проекту и к вашей задаче. Если вы не знаете, как работает какая-то технология, вы не можете быть уверены, что она делает то, что вы ожидаете. Наш деплоймент слишком медленный, давайте использовать другую систему CI/CD. У нас много данных, давайте начнем использовать Hadoop. Наша база данных SQL очень медленная, мы должны переключиться на базу данных NoSQL. Наша база данных NoSQL делает наши данные не консистентными, вместо нее мы должны использовать SQL базу данных, потому что она гарантирует согласованность. Я слышал такие предложения много-много раз.</p>
</div>
<div class="paragraph">
<p>Что происходит после того, как вы интегрировали новую классную технологию? Рано или поздно вы понимаете, что она не соответствует вашим требованиям. И вы начинаете настраивать ее для адаптации, но поскольку вы использовали неправильную технологию, она недостаточно гибкая, чтобы приспособиться к вашим потребностям. Вы могли бы потратить много времени в поисках способа ее адаптации, но решения не существует. Это был неправильный выбор. Единственное решение - найти хорошую замену и потратить время на переключение с неправильной технологии на правильную.</p>
</div>
<div class="sect3">
<h4 id="_Копайте_глубже_Понимание_делает_вас_быстрым">Копайте глубже. Понимание делает вас быстрым</h4>
<div class="paragraph">
<p>Итак, наш младший разработчик начинает читать Java doc, описывающий map, чтобы узнать, как он работает. Есть очень важный комментарий.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">/**
* &lt;p&gt;Note: great care must be exercised if mutable objects are used as map
 * keys.  The behavior of a map is not specified if the value of an object is
 * changed in a manner that affects &lt;tt&gt;equals&lt;/tt&gt; comparisons while the
 * object is a key in the map.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Хммм, наш класс Key изменяемый. Он не контролирует свое собственное состояние, некоторый внешний класс может изменить состояние, вызвав метод <code>setValue</code>.</p>
</div>
<div class="paragraph">
<p>Давайте проверим код.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Map&lt;Key, String&gt; map = new HashMap&lt;&gt;();
Key key = new Key(42);
map.put(key, "Goodbye, mad world");

//a lot of code here
//but we omit it

//This is the problem!!!!
key.setValue(0);

//a lot of code here
//but we omit it


//get value
log.debug("value is '{}'", map.get(key));

//has the map size been changed?
log.debug("map size is '{}'", map.size());

//do we still have the key in the map?
Key firstKey = map.keySet().iterator().next();
log.debug("check hash codes. equals? '{}'", firstKey.hashCode() == key.hashCode());
log.debug("is it the same key? '{}'", firstKey.equals(key));

//does map contain the key?
log.debug("map contains key? '{}'", map.containsKey(key));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Наш младший разработчик удаляет метод setValue из класса Key, исправляет все вызовы метода, и проблема решается.</p>
</div>
<div class="paragraph">
<p>Так что же случилось. Вместо того, чтобы тратить время на поиск в Google, наш гипотетический младший разработчик узнал, как работает HashMap.</p>
</div>
<div class="paragraph">
<p>Это реализация метода containsKey:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public boolean containsKey(Object key) {
        key = convertKey(key);
        int hashCode = hash(key);
        HashEntry entry = data[hashIndex(hashCode, data.length)]; // no local for hash index
        while (entry != null) {
            if (entry.hashCode == hashCode &amp;&amp; isEqualKey(key, entry.key)) {
                return true;
            }
            entry = entry.next;
        }
        return false;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Когда вы вызываете метод HashMap.put, ваш ключ и значение сохраняются в массиве данных как HashEntry. Индекс в массиве зависит от занчения hashCode ключа. Если состояние этого ключа изменилось, вы никогда не найдете его в массиве, потому что хэш-код ключа изменен. Вместо этого в некоторых случаях вы можете найти абсолютно другое значение, связанное с другим ключом.</p>
</div>
<div class="paragraph">
<p>Теперь очевидно, почему ключ должен быть неизменным. Должен ли наш разработчик расслабиться? И да и нет :)</p>
</div>
<div class="paragraph">
<p>Простое удаление метода <code>setValue</code> не делает наш класс Key полностью неизменным. Почему?</p>
</div>
<div class="paragraph">
<p>Это хороший вопрос. На самом деле, лучший способ научиться чему-то - это быть любопытным и задавать вопросы.</p>
</div>
<div class="paragraph">
<p>Что может быть ключом HashMap? Можете ли вы использовать Thread в качестве ключа? Может ли другой map быть ключом? Что если я передам null в качестве ключа? Что если я уберу ключ во время итерации по map? Сколько ключей может содержать HashMap? И так далее&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>Чтобы удовлетворить любопытство, наш гипотетический младший разработчик решил прочитать несколько книг по Java. И в книгах говорится, что для того, чтобы сделать некоторый объект неизменным, лучше объявить поля класса как <code>final</code>.</p>
</div>
<div class="paragraph">
<p>В каком случае отсутствие этого модификатора может нарушить неизменность? Если вы попытаетесь прочитать спецификацию Java Memory Model, вы можете найти ответ.</p>
</div>
<div class="paragraph">
<p>Может быть потенциальное состояние гонки, и <code>final</code> позволяет избежать этого. Это действительно редкий случай, и для его воспроизведения мне пришлось использовать опцию jvm <code>-UseCompressedOops</code>. Это не значит, что мы не должны пытаться избегать таких проблем. Наоборот, мы должны приложить все усилия, чтобы их исправить. На самом деле проблема с редко воспроизводимыми проблемами заключается в том, что они возникают на продакшене в самый неподходящий момент (например, во время демо), но в тестовой среде их очень трудно воспроизвести и, соответственно, очень трудно исправить их.</p>
</div>
<div class="paragraph">
<p>Я использовал <a href="http://openjdk.java.net/projects/code-tools/jcstress/">jcstress library</a>, чтобы продемонстрировать проблему. Тест создает два потока. Первый поток создает ключ, а второй считывает значение ключа. Это повторяется много раз, чтобы поймать все возможные случаи и увидеть, как часто происходит каждый из них.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@JCStressTest
@Description("Checking Key immutability.")
@Outcome(id = "[-42]", expect = Expect.ACCEPTABLE,             desc = "The key has not yet been published. It's ok the access is not syncronized")
@Outcome(id = "[42]",  expect = Expect.ACCEPTABLE,             desc = "The key has published and the value is visible. That's what we expect to have any time")
@Outcome(id = "[0]",   expect = Expect.ACCEPTABLE_INTERESTING, desc = "The key has published but default value is visible.")
@State
public class KeyIsNotImmutable {
    int x = 42;
    Key key;

    @Actor
    public void publish() {
        key = new Key(x);
    }

    @Actor
    public void consume(IntResult1 res) {
        Key localCopy = key;
        if (localCopy != null) {
            res.r1 = localCopy.hashCode();
        } else {
            res.r1 = -42;
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Вот результаты:</p>
</div>
<table class="tableblock frame-all grid-all spread" style="float: left;">
<colgroup>
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 22.2222%;">
<col style="width: 55.5556%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Observed state</th>
<th class="tableblock halign-left valign-top">Occurrences</th>
<th class="tableblock halign-left valign-top">Expectation</th>
<th class="tableblock halign-left valign-top">Interpretation</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">[-42]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">155,903,168</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ACCEPTABLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The key has not yet been published. It&#8217;s ok and not interesting</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">[42]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">14,756,652</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ACCEPTABLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The key has published and the value is visible. That&#8217;s what we expect to have any time</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">[0]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1,630</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ACCEPTABLE_INTERESTING</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The key has published but default value is visible.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Итак, final гарантирует, что у нас нет третьего случая. Теперь мы знаем, почему неизменяемые объекты должны иметь final поля.</p>
</div>
<div class="paragraph">
<p>Это то, что я называю обучением, основанным на любопытстве. Вы узнаете что-то новое, задаете вопросы, проводите эксперименты, чтобы увидеть, как все работает. Чем больше вы узнаете, тем больше у вас вопросов. Чем больше ответов вы найдете, тем глубже ваши знания. Tем лучше ваша производительность.</p>
</div>
<div class="paragraph">
<p>Задавайте вопросы, думайте, пишите код, будьте продуктивными!</p>
</div>
</div>
</div>
</div>
</div>
                    </div>
                    <div class="height-40px"></div>
                    <div>
                        <h4 class="text-center">Like it? Share it!</h4>
                        <div class="height-15px"></div>
                        <ul class="social">
                            <li class="facebook">
                                <a href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Fkonoplev.me&t="
                                   target="_blank" title="Share on Facebook"
                                   onclick="window.open('https://www.facebook.com/sharer/sharer.php?u=' + encodeURIComponent(document.URL)); return false;">
                	<span class="ion-social-facebook">
                                </a>
                            </li>
                            <li class="twitter">
                                <a href="https://twitter.com/intent/tweet?source=http%3A%2F%2Fkonoplev.me&text=:%20http%3A%2F%2Fkonoplev.me"
                                   target="_blank" title="Tweet"
                                   onclick="window.open('https://twitter.com/intent/tweet?text=' + encodeURIComponent(document.title) + ':%20' + encodeURIComponent(document.URL)); return false;">
                	<span class="ion-social-twitter">
                                </a>
                            </li>
                            <li class="pinterest">
                                <a href="http://pinterest.com/pin/create/button/?url=http%3A%2F%2Fkonoplev.me&description="
                                   target="_blank" title="Pin it"
                                   onclick="window.open('http://pinterest.com/pin/create/button/?url=' + encodeURIComponent(document.URL) + '&description=' +  encodeURIComponent(document.title)); return false;">
                	<span class="ion-social-pinterest">
                                </a>
                            </li>
                            <li class="reddit">
                                <a href="http://www.reddit.com/submit?url=http%3A%2F%2Fkonoplev.me&title="
                                   target="_blank" title="Submit to Reddit"
                                   onclick="window.open('http://www.reddit.com/submit?url=' + encodeURIComponent(document.URL) + '&title=' +  encodeURIComponent(document.title)); return false;">
                	<span class="ion-social-reddit">
                                </a>
                            </li>
                            <li class="linkedin">
                                <a href="http://www.linkedin.com/shareArticle?mini=true&url=http%3A%2F%2Fkonoplev.me&title=&summary=&source=http%3A%2F%2Fkonoplev.me"
                                   target="_blank" title="Share on LinkedIn"
                                   onclick="window.open('http://www.linkedin.com/shareArticle?mini=true&url=' + encodeURIComponent(document.URL) + '&title=' +  encodeURIComponent(document.title)); return false;">
                	<span class="ion-social-linkedin">
                                </a>
                            </li>
                            <li class="email-icon">
                                <a href="mailto:?subject=&body=:%20http%3A%2F%2Fkonoplev.me"
                                   target="_blank" title="Email"
                                   onclick="window.open('mailto:?subject=' + encodeURIComponent(document.title) + '&body=' +  encodeURIComponent(document.URL)); return false;">
                	<span class="ion-email">
                                </a>
                            </li>
                        </ul>

                    </div>
                    <div>
                        <div id="remark42" aria-live="polite">
                            <noscript>Please enable JavaScript to view the comments</noscript>
                        </div>
                    </div>
                </article>
            </main>
        </div>
    </div>
</div>

<script>
    var remark_config = {
        host: "https://comments.konoplev.me",
        site_id: 'konoplev',
    };

    (function(c) {
        for(var i = 0; i < c.length; i++){
            var d = document, s = d.createElement('script');
            s.src = remark_config.host + '/web/' +c[i] +'.js';
            s.defer = true;
            (d.head || d.body).appendChild(s);
        }
    })(remark_config.components || ['embed']);
</script>

<footer id="site-footer">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <p class="copyright">&copy; 2020 Alexander Konoplev</p>
            </div>
        </div>
    </div>
</footer>

<!-- Mobile Menu -->
<div class="overlay overlay-hugeinc">
    <button type="button" class="overlay-close"><span class="ion-ios-close-empty"></span></button>
    <nav>
        <ul>
            <li><a href="../../../ru/index.html">About</a></li>
            <li><a href="../../../ru/thoughts/index/1.html">Мысли</a></li>
            <li><a href="../../../ru/programming/index/1.html">Программирование</a></li>
        </ul>
    </nav>
</div>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
  (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

  ym(55474030, "init", {
    clickmap:true,
    trackLinks:true,
    accurateTrackBounce:true,
    webvisor:true
  });
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/55474030" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->

<script src="../../../js/script.js"></script>

</body>
</html>
